# -*- coding: utf-8 -*-
"""Compare.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w5fey3tPCfAApazSZQZIi3o0tYOoga8c
"""

#import pycountry
#import geograpy
#from geograpy import places
import requests
#from geograpy import extraction
import json
import matplotlib.pyplot as plt
import numpy as np 
#import pycountry_convert as pc
#from affiliation_parser import parse_affil
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
import re 
import urllib
import time
import csv
import pandas as pd
import numpy as np
#import tomotopy as tp
import nltk
from nltk.corpus import stopwords
nltk.download('stopwords')
nltk.download('punkt')
from nltk.tokenize import word_tokenize
import seaborn as sns
from nltk.stem import WordNetLemmatizer
nltk.download('wordnet')
from string import digits
from nltk.stem.lancaster import LancasterStemmer

from matplotlib import colors 
from matplotlib.ticker import PercentFormatter

def collect_year_count(query, lower, upper, retmax = 20000):
    retmode = "json"
    pyears = {}
    url_api = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=' +query+ '&retmode='+ retmode+'&retmax=' + str(retmax)
    for date in range(lower, upper + 1):
        year_url = url_api + '&datetype=pdat&mindate=' + str(date) +'&maxdate='+ str(date)
        re_year = requests.get(year_url)
        results = re_year.text
        data = json.loads(results)
        count = data["esearchresult"]["count"]
        pyears[str(date)] = int(count)  
        time.sleep(0.5)
    return pyears

totalYear = collect_year_count('', 1946, 2021, 20000) # 统计每年的paper数量

pyear = collect_year_count('pressure+ulcer', 1946, 2021, 20000) # 统计每年的paper数量

for i in pyear:
  pyear[i]=pyear[i]/totalYear[i]

fig = plt.figure(figsize =(15, 8)) #画paper数量分布图
ax = fig.add_axes([0,0,1,1])
index = np.arange(len(pyear))
ax.bar(index, pyear.values())
plt.xlabel('Years', fontsize=20) 
plt.ylabel('Number of Papers', fontsize=20)
plt.xticks(index, pyear.keys(), fontsize=8, rotation=45)
plt.title('Papers 1946 - 2021') #图片的题目名称 可更改
plt.show()

def get_idlist(query, date, retmax='10000'):
    retmode = "json"
    url_api = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term='+query+'&retmode='+ retmode+'&retmax='+retmax + '&datetype=pdat&mindate=' + str(date) +'&maxdate='+ str(date)
    re = requests.get(url_api)
    result = re.text
    data = json.loads(result)
    idlist = data["esearchresult"]["idlist"]
    return idlist

def get_year_idlist(query, lower, upper, retmax = 10000):
    year_list = []
    for date in range (lower, upper+1):
        idlist = get_idlist(query, date, str(retmax))
        year_list.append(idlist)
        print(date)
        time.sleep(1)
    return year_list

def ascii_remove(content): 
    content = content.encode('ascii',errors='ignore').decode('utf-8')      #removes non-ascii characters
    content = re.sub(r'\W', ' ', content)
    content = re.sub('\s+',' ',content) #repalces repeated whitespace characters with single space
    return content


def remove_js(soup): #removes script and style tags from HTML
    for script in soup(["script", "style"]):
        script.decompose()
    return soup

def calculate_dig(year_list):
    retmode = 'xml'
    dic_list = []
    abstract_lists = []
    titles = []
    count = 0
    lists = 0
    for index in range(len(year_list)):
        
        idset = []
        number = len(year_list[index])
        lastone = year_list[index][number - 1]
        string = ""
        count = 0
        for item in year_list[index]:
            if count == 160:
                count = 0
                string = string + item
                idset.append(string)
                string = ""
            elif item == lastone:
                string = string + item
                idset.append(string)
            else:
                string = string + item + ","
            count += 1
        year_features = []
        year_result = []
        year_title = []
        for i in range(0, len(idset)):    
            res = requests.get("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&retmode=" + retmode + "&id=" + idset[i])
            tree = ET.fromstring(res.text.encode("utf-8"))
            a = tree.findall("PubmedArticle/MedlineCitation")
            count += len(a)
            for citations in a:
                isR = False        
                features = []
                for types in citations.findall('Article/PublicationTypeList/PublicationType'):
                    if types.text == 'Review' or types.text == 'Letter':
                        isR = True
                        break
                if not isR:
                    p = citations.findall("MeshHeadingList/MeshHeading/DescriptorName") #find meshheading list
                    q = citations.findall("MeshHeadingList/MeshHeading/QualifierName")
                    title = citations.findall("Article/ArticleTitle")
                    ts = []
                    for t in title:
                        ts.append(t.text)
                    year_title.append(ts)
                    print(ts)
                    for item in p:
                        if 'diagnos' in item.text or 'diagnosis' in item.text or 'diagnostic' in item.text:
                            features.append(0)
                        if 'treat' in item.text or 'surgery' in item.text or 'operation' in item.text or 'therapy' in item.text or 'Operation' in item.text or 'surgical' in item.text or 'Intervention' in item.text:
                            features.append(1)
                        if 'Invasive' in item.text or 'invasive' in item.text:
                            features.append(2)
                        if 'Non-invasive' in item.text or 'Non-invasive' in item.text:
                            features.append(3) 
                        if 'minimally' in item.text or 'Minimally' in item.text:
                            features.append(4)
                        if 'intervention' in item.text or 'Intervention' in item.text:
                            features.append(5)
                        if 'endoscope' in item.text or 'Endoscope' in item.text or 'endoscopic' in item.text:
                            features.append(6)
                        if 'molecular' in item.text or 'Molecular' in item.text:
                            features.append(7)
                                                
                        if 'Gene' in item.text or 'gene' in item.text:
                            features.append(8)
                            
                        if 'finite element' in item.text or 'Finite element' in item.text:
                            features.append(9)    
                            
                    for item in q:
                        if 'diagnos' in item.text or 'diagnosis' in item.text or 'diagnostic' in item.text:
                            features.append(10)
                        if 'treat' in item.text or 'surgery' in item.text or 'operation' in item.text or 'therapy' in item.text or 'Operation' in item.text or 'surgical' in item.text or 'Intervention' in item.text:
                            features.append(11)
                        if 'Invasive' in item.text or 'invasive' in item.text:
                            features.append(12)
                        if 'Non-invasive' in item.text or 'Non-invasive' in item.text:
                            features.append(13) 
                        if 'minimally' in item.text or 'Minimally' in item.text:
                            features.append(14)
                        if 'intervention' in item.text or 'Intervention' in item.text:
                            features.append(15)
                        if 'endoscope' in item.text or 'Endoscope' in item.text or 'endoscopic' in item.text:
                            features.append(16)
                        if 'molecular' in item.text or 'Molecular' in item.text:
                            features.append(17)
                                                
                        if 'Gene' in item.text or 'gene' in item.text:
                            features.append(18)
                            
                        if 'finite element' in item.text or 'Finite element' in item.text:
                            features.append(19)
                    #get abstract:
                    summary = ""
                    abst = citations.findall("Article/Abstract/AbstractText")
                    for abstracts in abst:
                        if abstracts.text == None:
                            continue
                        summary += abstracts.text
                   
                    year_result.append(summary)
                

                year_features.append(features)        
            print(i)
        dic_list.append(year_features)
        abstract_lists.append(year_result)
        titles.append(year_title)
    return dic_list, abstract_lists, year_title

lemmatizer = WordNetLemmatizer() #define lemmatizer
stemmer = LancasterStemmer()

def tokenize_text(abstract):
    cleanText = ''
    ck = ascii_remove(abstract).lower()
    k_tokens = word_tokenize(ck)
    k_without_sw = [word for word in k_tokens if not word.lower() in stopwords.words("english")]
    for item in k_without_sw:
      cleanText += stemmer.stem(item) + ' '
    return cleanText

def raw_abstract(abstract_lists):
    features = []
    inv_title = []
    i = 0
    for years in abstract_lists:
        year_features = []
        j = 0
        for article in years:
            f = []
            if 'diagnos' in article or 'diagnosis' in article or 'diagnostic' in article:
                f.append(0)
            if 'treat' in article or 'surgery' in article or 'surgical' in article or 'operation' in article or 'therapy' in article or 'Operation' in article or 'surgical' in article or 'Intervention' in article or 'intervention' in article or 'operational' in article or 'conservative' in article :
                f.append(1)
            if 'Invasive' in article or 'invasive' in article:
                f.append(2)
                inv_title.append([i, j])
            if 'Non-invasive' in article or 'non-invasive' in article:
                f.append(3) 
            if 'minimally' in article or 'Minimally' in article:
                f.append(4)
            if 'intervention' in article or 'Intervention' in article:
                f.append(5)
            if 'endoscope' in article or 'Endoscope' in article or 'endoscopic' in article:
                f.append(6)
            if 'molecular' in article or 'Molecular' in article:
                f.append(7)

            if 'Genetic' in article or 'genetic' in article:
                f.append(8)

            if 'finite element' in article or 'Finite element' in article:
                f.append(9)   
            if 'minimally invasive' in article or 'Minimally invasive' in article:
                f.append(10)
            if 'conservative' in article or 'Conservative' in article:
                f.append(11)
            if 'surgical' in article or 'Surgical' in article:
                f.append(12)
            if 'post-operation'in article or 'Post-operation' in article or 'postoperative' in article or 'Postoperative' in article:
                f.append(13)
            if 'invasive operation'in article or 'Invasive operation'in article :
                f.append(14)
            year_features.append(f)
            j += 1
        i += 1
        features.append(year_features)
    return features, inv_title

def raw_abstract_search(abstract_lists, keyword_list):
    features = []
    inv_title = []
    i = 0
    length = len(keyword_list)
    for years in abstract_lists:
        year_features = []
        j = 0
        for article in years:
            f = []
            for number in range(length):
                for word in keyword_list[number]:
                    if word in article:
                        f.append(number)
                        break
            year_features.append(f)
            j += 1
        i += 1
        features.append(year_features)
    return features, inv_title

def count_features(abs_features, number):
    dia = []
    #i = 0
    for year in abs_features:
        d = 0
        #j = 0
        for article in year:
            if number in article:
                d += 1
                #print(i, j)
            #j += 1
        dia.append(d)
        #i += 1
    return dia

def count_without_overlap(abs_features, first, second):
    f = []
    s = []
    d = []
    for year in abs_features:
        a = 0
        b = 0
        c = 0
        for article in year:
            isD = 0
            set1 = set(article)
            if len(set1.intersection(first)):
                a += 1
                isD += 1
            if len(set1.intersection(second)):
                b += 1
                isD += 1
            if isD == 2:
                c += 1
        f.append(a - c)
        s.append(b - c)
        d.append(c)
    return f, s, d

def count_overlaps(abs_features, numbers):
    dia = []
    for year in abs_features:
        d = 0
        for article in year:
            set1 = set(article)
            inter = set1.intersection(numbers)
            if len(inter) > 0:
                d += 1
        dia.append(d)
    return dia

year_list = get_year_idlist('carpal+tunnel+syndrome', 2000, 2020) #get the id list. 根据需要更改疾病名字和年份范围， 空格用+替代， 前后两数字为所需年份上下限。

features, abstract_lists, titles = calculate_dig(year_list) #得到年份范围内的paper abstracts以及题目，年份范围由上一行定义。

abs_features, inv_title = raw_abstract(abstract_lists)

keyword_list = [['finite element', 'Finite element'], ['Genetic']] 
#设置keyword list， 格式为：[['词1', '词1变体1’, '词1变体2'], ['词2'], ['词3']], 每个词用引号，词组或短语用中的空格使用单个空格。可无限增加变体和词的数量。
#画图时 每个词的index为该关键词的编号， 如例子， 词1及其变体编号0， 词2及其变体编号1.
#如需要快速画图请自行设定变体， 变体包含：不同大小写

abs_features, inv_title = raw_abstract_search(abstract_lists, keyword_list) #抽取abstract中的关键词

conserv = count_overlaps(abs_features, [3, 11, 5]) 
#计算包含关键词list的paper总数量，等号左侧为结果变量名， 可更改，右侧包含数字的list定义具体需要的关键词，数字为关键词在keyword list的index。（paper包含任一关键词即计入数量，同一paper只计算一次）

surgica = count_overlaps(abs_features,[12, 13, 14])

minimally = count_overlaps(abs_features,[10, 6])

diagnosis          = count_features(abs_features, 0) #计算包含单个关键词的paper数量
treatment          = count_features(abs_features, 1)
invasive           = count_features(abs_features, 2)
Non_invasive       = count_features(abs_features, 3)
minimally          = count_features(abs_features, 4)
intervention       = count_features(abs_features, 5)
endoscope          = count_features(abs_features, 6)
molecular          = count_features(abs_features, 7)
genetic            = count_features(abs_features, 8)
finite_element     = count_features(abs_features, 9)
minimally_invasive = count_features(abs_features, 10)
conservative       = count_features(abs_features, 11)
surgical           = count_features(abs_features, 12)
post_operation     = count_features(abs_features, 13)
invasive_operation = count_features(abs_features, 14)

first, second, overlap = count_without_overlap(abs_features, [11], [12]) 
#计算分别含关键词1， 关键词2的paper数量， 等号左侧分别为 第一个词[11,近义词]的paper数， 第二个词的paper数， 同时包含两个词的paper数, 左侧三个变量名字可随意更改

def create_years(lower, upper):
  years = []
  for i in range (lower, upper + 1): 
    years.append(i)
  return years

years = create_years(2000, 2020) #创建年份list, 注意保持一致

sns.set(style = 'darkgrid')
fig = plt.figure(figsize =(12, 8)) # figsize=(12, 8)为图片的大小， 更改数字可更改图片大小， 12为长8为宽
plt.plot(years[:21], conserv[:21], marker='o', label = 'Conservative') 
#需要更改的部分：两个[:21], 21改为年份范围的长度，例如2010-2012共三年， 改成[:3]; marker前面的，第一个逗号后面的变量名，更改成需要画的结果变量名即可；label = 后面的，自定义该曲线的名称
#每一个plt.plot代表图上一根曲线，需要多跟曲线自行增加。
plt.plot(years[:21], surgica[:21], marker='o', label = 'Surgery')
plt.plot(years[:21], minimally[:21], marker='o', label = 'minimally')
plt.xticks(range(2000, 2021)) #range(年份下限， 年份上限)， 记得保持一致
plt.legend()

sns.set(style = 'darkgrid')
fig = plt.figure(figsize =(12, 8)) # figsize=(12, 8)为图片的大小， 更改数字可更改图片大小， 12为长8为宽
plt.plot(years[:21], first[:21], marker='o', label = 'Conservative') 
#需要更改的部分：两个[:21], 21改为年份范围的长度，例如2010-2012共三年， 改成[:3]; marker前面的，第一个逗号后面的变量名，更改成需要画的结果变量名即可；label = 后面的，自定义该曲线的名称
#每一个plt.plot代表图上一根曲线，需要多跟曲线自行增加。
plt.plot(years[:21], second[:21], marker='o', label = 'Surgery')
plt.plot(years[:21], overlap[:21], marker='o', label = 'minimally')
plt.xticks(range(2000, 2021)) #range(年份下限， 年份上限)， 记得保持一致
plt.legend()

